#!/usr/bin/perl -w
# ┌──────────────────────────────────────────────────────────────────────────────────┐
# │ Krzysztof Abramowicz (http://krzysztofabramowicz.com/, k.j.abramowicz@gmail.com) │
# │   project: HyperVision — Architectonic Rendering Engine                          │
# │             └─HV Application Framework                                           │
# │                └─HV C PreProcessor (hvCPP)                                       │
# │   toolset: Perl 5.8+                                                             │
# │   content: Main preprocessing script (UTF-8, text/x-script.perl)                 │
# │   version: 0.9 OS                                                                │
# └──────────────────────────────────────────────────────────────────────────────────┘

# Accepted command-line parameters are:
#   ├─ -I [file] ➤ input file
#   │               ├─example: my_module.in
#   │               └─default: STDIN
#   ├─ -O [file] ➤ output file (general/public stream output)
#   │               ├─example: my_module.h
#   │               └─default: STDOUT
#   └─ -R [file] ➤ private stream output file
#                   ├─example: my_module_p.h, my_module.r
#                   └─default: $(SRC_DIR)/$(MODULE_NAME)_p.h

# 0./ Enable pragmas, load libraries, declare prototypes
use utf8;
use strict;
use warnings;
use Math::Trig;
use Getopt::Std;

sub gjoin($$$@);
sub cleanReaderC99($$);
sub cleanReaderGAS($$);
sub cleanReaderOBJ($$);

# 1./ Define trigonometric functions wrappers for:
#       • using degrees instead of radians as the angle measurement units,
#       • invocation by function pointers (core functions cannot be referenced).
sub deg_sin($) {
	return sin($_[0] * pi / 180)
}
sub deg_cos($) {
	return cos($_[0] * pi / 180)
}
sub deg_ctg($) {
	$_[0] == 0   && return  99;
	$_[0] == 180 && return -99;
	return cot($_[0] * pi / 180);
}

# 2./ Load shell-exported make variables (or use default values)
my $INC_DIR = defined $ENV{'incdir'} ? $ENV{'incdir'} : 'inc';
my $SRC_DIR = defined $ENV{'srcdir'} ? $ENV{'srcdir'} : 'src';

# 3./ Load configuration parameters form the command line (or use default values)
my %opt;
getopts "I:O:", \%opt || die "hvCPP: Unknown switch.\n";

my ($IN, $PUB, $PRV, $VPATH, $MODULE, $FILE);
$VPATH = './src';
$MODULE = '';
$FILE = 'stdin';

if (defined $opt{'I'}) {
	(-r "$opt{'I'}") || die "hvCPP:$opt{'I'}: file does not exist or cannot be accessed.\n";
	open $IN, '<', $opt{'I'};
	$FILE = $opt{'I'};
	if ($MODULE eq '') {
		$opt{'I'} =~ m/([^\/]+)\.[a-z]{1,5}$/;
		$MODULE = $1
	}
} else {
	open $IN, '<&', "STDIN"
}

if (defined $opt{'O'}) {
	open $PUB, '>', $opt{'O'} || die "hvCPP:$opt{'O'}: cannot create file.\n";
	select $PUB;
	if ($MODULE eq '') {
		$opt{'O'} =~ m/([^\/]+)\.[a-z]{1,5}$/;
		$MODULE = $1
	};
} else {
	open $PUB, '>&', "STDOUT";
};

# 4./ Preprocess the input stream
my (@mtab, @vstab, @fstab, $inline, $lnr, $ind, $yummy);
$yummy = 0;
print "/* File generated by hvCPP as public header for \"$MODULE\" module */\n";
while ($inline = cleanReaderC99($IN, $lnr)) {
	chomp $inline;
	++$lnr;
	if ($inline =~ m/^([\t\s])*#pragma hv (.+)/) {
		($ind, $_) = ($1, $2);
		SWITCH: {

			# 4.1: vpath: setting vertical path for merging external sources
			/vpath\("(.+)"\)/ && do {
				$VPATH = $1;
				last SWITCH
			};

			# 4.2: public: direct upcomming output to public stream
			/public/ && do {
				select $PUB;
				$yummy = 1;
				last SWITCH
			};

			# 4.3: private: direct upcomming output to private stream
			/private/ && do {
				# 2.3.?: check if private stream is already opened
				if (defined $PRV) {
					# 2.3.t: redirect output to PRV
					select $PRV
				}
				else {
					# 2.3.f: open PRV with provided name (-R) or construct it from PUB name (-O)
					if (defined $opt{'R'}) {
						open $PRV, '>', $opt{'R'} || die "hvCPP:$opt{'R'}: cannot create file.\n"
					} else {
						open $PRV, '>', "$SRC_DIR/$MODULE"."_p.h"
					}
					select $PRV;
					print "/* File generated by hvCPP preprocessor as private header for \"$MODULE\" module */\n"
				}
				$yummy = 1;
				last SWITCH
			};

			# 4.4: merge: include sources written in other languages using appropriate formatting
			/merge\("(.+)"\)/ && do {
				# 4.4.1: merge GLSL shader program sources
				if ($1 =~ m/(.+)\.(.+)\.glsl/) {
					# 4.4.1.1: construct complete path and open the shader file
					my ($sh_name, $sh_type, $sh_path) = ($1, $2, "$VPATH/$&");
					(-r "$sh_path") || die "hvCPP:$sh_path: file does not exist or cannot be accessed.\n";
					open my $sh_file, '<', "$sh_path";
					# 4.4.1.2: determine the shader name and push it on appropriate symbol table
					if ($sh_type eq 'vs') {
						$sh_name .= 'VertexShader';
						push @vstab, $sh_name
					}
					elsif ($sh_type eq 'fs') {
						$sh_name .= 'FragmentShader';
						push @fstab, $sh_name
					}
					else {
						die "hvCPP:$FILE:$lnr: unknown shader type (\"$sh_type\") for GLSL merge.\n"
					};
					# 4.4.1.3: reformat GLSL as GLchar* constant
					print "\nstatic const GLchar* $sh_name = {\n";
					while (my $fl = cleanReaderC99($sh_file, my $sh_lnr = 0)) {
						chomp $fl;
						print scalar ($fl eq ''     ? "\n"              :
						             ($fl eq "\x7d" ? "\t\"$fl\\n\"\n"  :
						                              "\t\"$fl\\n\"\\\n"));
					}
					print "};\n";
					close $sh_file
				}
				# 4.4.2: merge .obj model mesh
				elsif ($1 =~ m/(.+)\.obj/) {
					# 4.4.2.1: get model name and store it in appropiate symbol table | construct .obj file path and open it
					my ($obj_name, $obj_path) = ("$1Model", "$VPATH/$&");
					(-r "$obj_path") || die "hvCPP:$obj_path: file does not exist or can not be accessed.\n";
					open my $obj_file, '<', "$obj_path";
					push @mtab, $obj_name;
					# 4.4.2.2: extract and store preformatted data records in vertices and faces arrays
					my $re_int = '[\s\t]*?(\d{1,4})';
					my $re_flt = '[\s\t]*?([-\s]\d{1,4}\.\d{1,4})';
					my (@vertices, @normals, @faces, $name);
					while (my $obj_line = cleanReaderOBJ($obj_file, my $obj_lnr = 0)) {
						if ($obj_line =~ m/^v$re_flt$re_flt$re_flt$/o) {
							push @vertices, "{$1f, $2f, $3f}"
						}
						elsif ($obj_line =~ m/^vn$re_flt$re_flt$re_flt/o) {
							push @normals, "{$1f, $2f, $3f}"
						}
						elsif ($obj_line =~ m/^f$re_int$re_int$re_int$/o) {
							push @faces, sprintf "%2d, %2d, %2d", $1, $2, $3
						}
						elsif ($obj_line =~ m/^o[\s\t](\w{1,12})$/o) {
							$name = $1
						}
						else {
							die "hvCPP:$obj_path:$obj_lnr: syntax error.\nhvCPP:\"$obj_line\"\n";
						}
					}
					close $obj_file;
					# 4.4.2.4: Splice normals and vertices (for one interleaved declaration)
					($#vertices != $#normals) &&
						die "hvCPP:$obj_path: number of normals does not correspond to the number of vertices.\n";
					@vertices = map {'{'.$vertices[$_].', '.$normals[$_].'}'} (0 .. $#vertices);
					# 4.4.2.4: construct vertex array C'99 definition
					print "\n$ind".'static vtx3_t '.$obj_name.'Vertices['.($#vertices+1)."] = {\n$ind\t";
					print join ",\n$ind\t", @vertices;
					print "\n$ind};\n";
					# 4.4.2.5: construct index array C'99 definition
					print "\n$ind".'static GLushort '.$obj_name.'Indices['.(($#faces+1)*3)."] = {\n$ind\t";
					print gjoin ",\n$ind\t", 4, ',   ', @faces;
					print "\n$ind};\n";
					# 4.4.2.6: construct mesh structure C'99 definition
					print "\n$ind"."static const mesh_t $obj_name = {" .
					      "\n$ind\t"."\"$name\"," .
					      "\n$ind\t".$obj_name."Vertices,\n$ind\t".$obj_name.'Indices,' .
					      "\n$ind\t".($#vertices+1).', '.(($#faces+1)*3)."\n$ind};\n";
				}
				# 4.4.3: merge GAS assembly code
				elsif ($1 =~ m/(.+)\.s/) {
					# comming soon :-)
				}
				# 4.4.E: report error and exit
				else {
					die "hvCPP:$FILE:$lnr: unknown source type for merge.\n"
				};
				last SWITCH
			};
			# 4.5: table: include an hvCPP internal symbol table or generate a lookup table (as C'99 code)
			/table\((.+)\)/ && do {
				# 4.5.1: include stock model pointers table for merged .obj meshes
				if ($1 eq 'model.ptr') {
					# 4.5.1.0: check if any models were merged 
					scalar @mtab == 0 && die "hvCPP:$FILE:$lnr: cannot create stock model pointers table from empty list.\n";
					# 4.5.1.1: create pointers table for merged models
					print "\n$ind".'static const mesh_t* stockModel[] = {';
					print join ',', map("\n$ind\t&$_", @mtab);
					print "\n$ind};\n";
					last SWITCH
				}
				# 4.5.2: include stock model enumerator for merged .obj meshes
				elsif ($1 eq 'model.enum') {
					# 4.5.2.0: check if any models were merged
					scalar @mtab == 0 && die "hvCPP:$FILE:$lnr: cannot create stock model enumerator from empty list.\n";
					# 4.5.2.1: create enumerator for merged models
					print "\n$ind".'enum smodel_e {';
					print join ',', map {s/(.+)Model/\n$ind\tHV_MODEL_\U$1/; $_} @mtab;
					print "\n$ind};\n";
					last SWITCH					
				}
				# 4.5.3: include stock shader pointers table for merged GLSL shaders
				elsif ($1 eq 'shader.ptr') {
					# 4.5.3.0: check if any shaders were merged
					(scalar @vstab == 0 || scalar @fstab == 0)
						&& die "hvCPP:$FILE:$lnr: cannot create stock shader pointers table from empty list.\n";
					# 4.5.3.1: create pointers table for merged vertex shaders
					print "\n".'static const GLchar** stockVertexShader[] = {';
					print join ',', map("\n\t&$_", @vstab);
					print "\n};\n";
					# 4.5.3.2: create pointers table for merged fragment shaders
					print "\n".'static const GLchar** stockFragmentShader[] = {';
					print join ',', map("\n\t&$_", @fstab);
					print "\n};\n";
					last SWITCH			
				}
				# 4.5.4: include stock shader pointers table for merged GLSL shader
				elsif ($1 eq 'shader.enum') {
					# 4.5.4.0: check if any symbols were gathered
					(scalar @vstab == 0 || scalar @fstab == 0)
						&& die "hvCPP:$FILE:$lnr: cannot create stock shaders enumerators from empty lists.\n";
					# 4.5.4.1: create enumerator for merged vertex shaders
					print "\n$ind".'enum vs_e {';
					print join ',', map {s/(.+)VertexShader/\n$ind\tHV_VSHADER_\U$1/; $_} @vstab;
					print "\n$ind};\n";
					# 4.5.4.2: create enumerator for merged fragment shaders
					print "\n$ind".'enum fs_e {';
					print join ',', map {s/(.+)FragmentShader/\n$ind\tHV_FSHADER_\U$1/; $_} @fstab;
					print "\n$ind};\n";
					last SWITCH
				}
				elsif ($1 =~ m/^(sin|cos|ctg)\((\d+)\:(\d+)\),\s?(float|double),\s?'(\w+)'/) {
					my ($func, $lbnd, $hbnd, $type, $name, $len) = ($1, $2, $3, $4, $5, $3 - $2);
					print $ind."static const $type $name\[$len\] = {";
					my ($row, $frm) = ($type eq 'float') ? (10, "%9.5ff") : (6, "%14.10f"); 
					my $fnc = ($func eq 'sin') ? \&deg_sin :
						      ($func eq 'cos') ? \&deg_cos : \&deg_ctg;
					for (my $i = $lbnd; $i < $hbnd - 1; ++$i) {
						($i % $row == 0) && print "\n$ind\t";
						printf "$frm, ", &$fnc($i);
					};
					printf "$frm\n$ind};\n\n", &$fnc($lbnd);
					last SWITCH			
				}
				else {
					die "hcCPP:$FILE:$lnr: syntax error within table statement.\n"
				}
			};
		} # SWITCH
	} else {		
		if ($yummy > 0 && $inline eq '') {
			$yummy = 0;
		} else {
			print "$inline\n"
		}
	}
}

exit 0;


#  .: S U B R O U T I N E S :.

# S: Join and group an array into n-tuples and output as single scalar
#    (use different separators for inter-element and inter-tuple joins)
sub gjoin($$$@) {
	my $gjlist = '';
	my ($tsep, $tsize, $esep, @elements) = @_;
	$gjlist .= $elements[0];
	for (my $i = 1; $i <= $#elements; ++$i) {
		$gjlist .= ($i % $tsize == 0) ? $tsep : $esep;
		$gjlist .= $elements[$i];
	}
	return $gjlist;
}

# S: Input filter with OBJ comments and excess keywords removal
sub cleanReaderOBJ($$) {
	my ($in, $nr, $ln) = ($_[0], \$_[1], undef);
	{
		# S.1: undef up-propagation (to preserve caller-side EOF detection)
		defined($ln = <$in>) || last;
		chomp $ln;
		$$nr++;
		# S.2: clear indentation
		$ln =~ s/^[\s\t]+//;
		# S.3: remove line comment
		$ln =~ s/#.*//;
		# S.4: ignore excess keywords
		$ln =~ s/^g[\s\t]\w+//;
		# S.5: cut extra right padding
		$ln =~ s/[\s\t]+$//;
		# S.6: eat the line in case of being empty
		$ln eq '' && redo
	}
	return $ln
}

# S: Input filter with GNU assembly (AT&T notation) comments removal
sub cleanReaderGAS($$) {
}

# S: Input filter with C'99-style comments removal
sub cleanReaderC99($$) {
	my ($in, $nr) = ($_[0], \$_[1]);
	if (defined(my $line = <$in>)) {
		while ($line =~ m/\/\*|\/\//) {
			chomp $line;
			# 1.1: skip single-line block comments
			$line =~ s/\/\*.*?\*\///g;
			# 1.2: remove line comment
			$line =~ s/\/\/.*$//;
			# 1.3: delete multi-line block comment
			if ($line =~ m/^(.*?)\/\*.*$/) {
				$line = $1;
				while (<$in>) {
					chomp;
					$$nr++;
					/^.*?\*\/(.*)$/ && do {
						$line .= $1;
						last
					}
				}
				# 1.3a remove line comment at the end of the multi-line block comment
				$line =~ s/\/\/.*$//;
			}
			# 1.4: cut extra right padding
			$line =~ s/[\s\t]+$//;
			# 1.5: eat the line in case of being empty
			if ($line eq '') {
				$line = <$in>;
				next
			}
			return "$line\n"
		}
		return $line
	}
	return undef
}

